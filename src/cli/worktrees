#!/bin/bash

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly VERSION="0.1.0"

# Source dependencies
source "$SCRIPT_DIR/../lib/io.sh"
source "$SCRIPT_DIR/../lib/json.sh"
source "$SCRIPT_DIR/../models/list_query.sh"
source "$SCRIPT_DIR/../models/worktree.sh"
source "$SCRIPT_DIR/../models/feature_name.sh"
source "$SCRIPT_DIR/../models/repository.sh"

show_help() {
	cat <<EOF
worktrees - Manage Git feature worktrees

USAGE:
    worktrees [GLOBAL_OPTIONS] <COMMAND> [COMMAND_OPTIONS]

GLOBAL OPTIONS:
    --help, -h         Show this help message
    --version, -v      Show version information
    --format <format>  Output format (text|json) [default: text]

COMMANDS:
    create <name>      Create a new worktree
    list               List existing worktrees
    switch <name>      Switch to a worktree
    remove <name>      Remove a worktree
    status             Show current worktree status

Use 'worktrees <command> --help' for more information on a specific command.
EOF
}

show_version() {
	echo "worktrees $VERSION"
}

show_create_help() {
	cat <<EOF
worktrees create - Create a new worktree

USAGE:
    worktrees create <NNN-kebab-feature> [OPTIONS]

ARGUMENTS:
    <NNN-kebab-feature>    Feature name in format 001-feature-name

OPTIONS:
    --base <branch>        Base branch/commit to create from [default: auto-detect]
    --root <path>          Root directory for worktrees [default: ~/.worktrees]
    --reuse-branch         Reuse existing branch if it exists
    --sibling              Create as sibling to current worktree
    --format <format>      Output format (text|json) [default: text]
    --help, -h             Show this help message

EXAMPLES:
    worktrees create 001-new-feature
    worktrees create 002-bug-fix --base develop
    worktrees create 003-experiment --root /tmp/worktrees
EOF
}

show_list_help() {
	cat <<EOF
worktrees list - List existing worktrees

USAGE:
    worktrees list [OPTIONS]

OPTIONS:
    --filter-name <pattern>    Filter worktrees by name pattern
    --filter-base <branch>     Filter by base branch
    --page <number>            Page number for pagination [default: 1]
    --page-size <size>         Items per page [default: 20, max: 100]
    --no-status                Skip expensive status checks (faster for large repos)
    --root <path>              Root directory for worktrees [default: ~/.worktrees]
    --format <format>          Output format (text|json) [default: text]
    --help, -h                 Show this help message

EXAMPLES:
    worktrees list
    worktrees list --filter-name "001-*"
    worktrees list --filter-base main --page-size 20
    worktrees list --format json
EOF
}

show_switch_help() {
	cat <<EOF
worktrees switch - Switch to a different worktree

USAGE:
    worktrees switch <name> [OPTIONS]

ARGUMENTS:
    <name>                 Name of the worktree to switch to

OPTIONS:
    --root <path>          Root directory for worktrees [default: ~/.worktrees]
    --format <format>      Output format (text|json) [default: text]
    --help, -h             Show this help message

EXAMPLES:
    worktrees switch 001-feature-branch
    worktrees switch main
EOF
}

show_remove_help() {
	cat <<EOF
worktrees remove - Remove an existing worktree

USAGE:
    worktrees remove <name> [OPTIONS]

ARGUMENTS:
    <name>                     Name of the worktree to remove

OPTIONS:
    --delete-branch            Delete the associated branch after removal
    --merged-into <branch>     Verify branch is merged into this branch before deletion
    --force                    Force removal even with untracked files
    --root <path>              Root directory for worktrees [default: ~/.worktrees]
    --format <format>          Output format (text|json) [default: text]
    --help, -h                 Show this help message

SAFETY:
    - Tracked changes, unpushed commits, and operations in progress block removal
    - Untracked files require --force flag
    - Branch deletion requires --merged-into for safety verification

EXAMPLES:
    worktrees remove 001-old-feature
    worktrees remove 002-completed --delete-branch --merged-into main
    worktrees remove 003-experimental --force
EOF
}

show_status_help() {
	cat <<EOF
worktrees status - Show current worktree status

USAGE:
    worktrees status [OPTIONS]

OPTIONS:
    --root <path>          Root directory for worktrees [default: ~/.worktrees]
    --format <format>      Output format (text|json) [default: text]
    --help, -h             Show this help message

DESCRIPTION:
    Shows information about the currently active worktree including:
    - Current worktree name and path
    - Base reference
    - Status warnings if any issues are detected

EXAMPLES:
    worktrees status
    worktrees status --format json
EOF
}

handle_create_command() {
	local format="$1"
	shift

	# Check for help flag first
	for arg in "$@"; do
		if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
			show_create_help
			exit 0
		fi
	done

	# Required positional argument: feature name
	if [[ $# -eq 0 ]]; then
		log_error "Feature name is required"
		echo "Usage: worktrees create <NNN-kebab-feature> [options]" >&2
		exit_with_code "validation"
	fi

	local feature_name="$1"
	shift

	# Default values
	local base_ref=""
	local root_path=""
	local reuse_branch=false
	local sibling=""

	# Parse create-specific arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
			--base)
				if [[ $# -lt 2 ]]; then
					log_error "--base requires an argument"
					exit_with_code "validation"
				fi
				base_ref="$2"
				shift 2
				;;
			--root)
				if [[ $# -lt 2 ]]; then
					log_error "--root requires an argument"
					exit_with_code "validation"
				fi
				root_path="$2"
				shift 2
				;;
			--reuse-branch)
				reuse_branch=true
				shift
				;;
			--sibling)
				if [[ $# -lt 2 ]]; then
					log_error "--sibling requires an argument"
					exit_with_code "validation"
				fi
				sibling="$2"
				shift 2
				;;
			*)
				log_error "Unknown option for create command: $1"
				exit_with_code "validation"
				;;
		esac
	done

	# Check if we're in a git repository
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		log_error "Not in a Git repository"
		exit_with_code "precondition"
	fi

	# Validate feature name format
	if ! validate_feature_name "$feature_name"; then
		exit_with_code "validation"
	fi

	# Check if feature name is reserved
	if is_reserved_name "$feature_name"; then
		log_error "Feature name '$feature_name' is reserved"
		exit_with_code "validation"
	fi

	# Detect default base branch if not provided
	if [[ -z "$base_ref" ]]; then
		if ! base_ref=$(get_default_branch); then
			log_error "Could not determine default base branch. Please specify with --base"
			exit_with_code "precondition"
		fi
		log_info "Using detected base branch: $base_ref"
	fi

	# Resolve worktree root directory (creates if missing)
	if ! root_path=$(resolve_worktrees_root "$root_path"); then
		log_error "Failed to resolve worktree root directory"
		exit_with_code "precondition"
	fi

	# Check if branch already exists and handle accordingly
	local branch_name="$feature_name"
	local branch_exists=false
	local branch_checked_out=false

	if git show-ref --verify --quiet "refs/heads/$branch_name"; then
		branch_exists=true
		# Check if branch is already checked out in another worktree
		if git worktree list --porcelain | grep -q "branch refs/heads/$branch_name"; then
			branch_checked_out=true
		fi
	fi

	# Handle branch conflicts
	if [[ "$branch_checked_out" == "true" ]]; then
		if [[ -n "$sibling" ]]; then
			branch_name="${feature_name}-${sibling}"
			log_info "Using sibling branch: $branch_name"
		elif [[ "$reuse_branch" == "true" ]]; then
			log_error "Branch '$feature_name' is already checked out and --reuse-branch was specified"
			log_error "Use --sibling <suffix> to create a sibling branch instead"
			exit_with_code "conflict"
		else
			log_error "Branch '$feature_name' is already checked out in another worktree"
			log_error "Use --sibling <suffix> to create a sibling branch or --reuse-branch if appropriate"
			exit_with_code "conflict"
		fi
	fi

	# Determine final worktree path (use branch name for sibling directories)
	local worktree_name="$feature_name"
	if [[ -n "$sibling" ]]; then
		worktree_name="$branch_name"
	fi
	local worktree_path="$root_path/$worktree_name"

	# Check if worktree directory already exists
	if [[ -d "$worktree_path" ]]; then
		log_error "Worktree directory already exists: $worktree_path"
		exit_with_code "conflict"
	fi

	# Create the worktree
	local git_cmd=("git" "worktree" "add")

	if [[ "$branch_exists" == "true" && "$reuse_branch" == "true" && "$branch_checked_out" == "false" ]]; then
		# Reuse existing branch
		git_cmd+=("$worktree_path" "$branch_name")
		log_info "Reusing existing branch: $branch_name"
	elif [[ -n "$sibling" ]]; then
		# Create new sibling branch from base
		git_cmd+=("-b" "$branch_name" "$worktree_path" "$base_ref")
		log_info "Creating sibling branch '$branch_name' from '$base_ref'"
	else
		# Create new branch from base
		git_cmd+=("-b" "$branch_name" "$worktree_path" "$base_ref")
		log_info "Creating branch '$branch_name' from '$base_ref'"
	fi

	# Execute git worktree add command
	if ! "${git_cmd[@]}" 2>&1; then
		log_error "Failed to create worktree"
		exit_with_code "precondition"
	fi

	# Verify worktree was created successfully
	if [[ ! -d "$worktree_path" ]]; then
		log_error "Worktree directory was not created: $worktree_path"
		exit_with_code "precondition"
	fi

	# Format output
	if [[ "$format" == "json" ]]; then
		local json_output
		json_output=$(json_format_worktree "$worktree_name" "$branch_name" "$base_ref" "$worktree_path" "true" "false" "false")
		echo "$json_output"
	else
		echo "Created worktree '$worktree_name' at $worktree_path"
		echo "Branch: $branch_name (from $base_ref)"
	fi

	log_info "Successfully created worktree: $worktree_name"
}

handle_switch_command() {
	local format="$1"
	shift

	# Check for help flag first
	for arg in "$@"; do
		if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
			show_switch_help
			exit 0
		fi
	done

	# Required positional argument: worktree name
	if [[ $# -eq 0 ]]; then
		log_error "Worktree name is required"
		echo "Usage: worktrees switch <name>" >&2
		exit_with_code "validation"
	fi

	local target_name="$1"
	shift

	# Default values
	local root_path=""

	# Parse switch-specific arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
			--root)
				if [[ $# -lt 2 ]]; then
					log_error "--root requires an argument"
					exit_with_code "validation"
				fi
				root_path="$2"
				shift 2
				;;
			*)
				log_error "Unknown option for switch command: $1"
				exit_with_code "validation"
				;;
		esac
	done

	# Check if we're in a git repository
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		log_error "Not in a Git repository"
		exit_with_code "precondition"
	fi

	# Parse worktrees from git
	parse_worktree_list

	# Check if target worktree exists
	if ! worktree_exists "$target_name"; then
		log_error "Worktree '$target_name' not found"
		exit_with_code "not_found"
	fi

	# Get target worktree information
	local target_path
	target_path=$(get_worktree_field "$target_name" "path")

	# Check if target path exists
	if [[ ! -d "$target_path" ]]; then
		log_error "Worktree directory does not exist: $target_path"
		exit_with_code "not_found"
	fi

	# Find current worktree (if any)
	local current_name=""
	local current_path=""
	local all_names=()
	while IFS= read -r name; do
		all_names+=("$name")
	done < <(list_worktree_names)

	for name in "${all_names[@]}"; do
		if is_worktree_active "$name"; then
			current_name="$name"
			current_path=$(get_worktree_field "$name" "path")
			break
		fi
	done

	# If we didn't find an active worktree, use the current directory
	if [[ -z "$current_name" ]]; then
		current_path="$(pwd)"
		# Try to get the name from the path
		if [[ "$current_path" =~ ([^/]+)$ ]]; then
			current_name="${BASH_REMATCH[1]}"
		else
			current_name="main"
		fi
	fi

	# Generate warnings by checking current worktree status
	local warnings=()

	if [[ -n "$current_name" ]] && worktree_exists "$current_name"; then
		# Get status of current worktree
		local is_dirty has_untracked op_in_progress
		is_dirty=$(get_worktree_field "$current_name" "isDirty")
		has_untracked=$(get_worktree_field "$current_name" "hasUntracked")
		op_in_progress=$(get_worktree_field "$current_name" "opInProgress")

		if [[ "$is_dirty" == "true" ]]; then
			warnings+=("Current worktree has uncommitted changes")
		fi
		if [[ "$has_untracked" == "true" ]]; then
			warnings+=("Current worktree has untracked files")
		fi
		if [[ "$op_in_progress" != "none" ]]; then
			warnings+=("Current worktree has operation in progress: $op_in_progress")
		fi
	fi

	# Check if we're already in the target worktree
	if [[ "$current_name" == "$target_name" ]]; then
		if [[ "$format" == "json" ]]; then
			local json_output
			json_output=$(json_format_switch "$current_name" "$current_path" "$current_name" "$current_path" "${warnings[@]}")
			echo "$json_output"
		else
			echo "Already in worktree '$target_name'"
			if [[ ${#warnings[@]} -gt 0 ]]; then
				for warning in "${warnings[@]}"; do
					log_warning "$warning"
				done
			fi
		fi
		return 0
	fi

	# Format output
	if [[ "$format" == "json" ]]; then
		local json_output
		if [[ ${#warnings[@]} -eq 0 ]]; then
			json_output=$(json_format_switch "$target_name" "$target_path" "$current_name" "$current_path")
		else
			json_output=$(json_format_switch "$target_name" "$target_path" "$current_name" "$current_path" "${warnings[@]}")
		fi
		echo "$json_output"
	else
		echo "Switch to worktree '$target_name' at: $target_path"
		echo ""
		echo "To complete the switch, run:"
		echo "  cd \"$target_path\""
		echo ""
		if [[ ${#warnings[@]} -gt 0 ]]; then
			echo "Warnings from previous worktree:"
			for warning in "${warnings[@]}"; do
				log_warning "$warning"
			done
		fi
		echo ""
		echo "Consider creating a shell function for automatic switching:"
		echo "  function wt-switch() { eval \"\$(./src/cli/worktrees switch \"\$1\" --format json | jq -r '.current.path | \"cd \\\"\" + . + \"\\\"\"')\"; }"
	fi

	log_info "Switch prepared from '$current_name' to '$target_name'"
}

handle_remove_command() {
	local format="$1"
	shift

	# Check for help flag first
	for arg in "$@"; do
		if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
			show_remove_help
			exit 0
		fi
	done

	# Required positional argument: worktree name
	if [[ $# -eq 0 ]]; then
		log_error "Worktree name is required"
		echo "Usage: worktrees remove <name> [options]" >&2
		exit_with_code "validation"
	fi

	local target_name="$1"
	shift

	# Default values
	local delete_branch=false
	local merged_into=""
	local force=false
	local root_path=""

	# Parse remove-specific arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
			--delete-branch)
				delete_branch=true
				shift
				;;
			--merged-into)
				if [[ $# -lt 2 ]]; then
					log_error "--merged-into requires an argument"
					exit_with_code "validation"
				fi
				merged_into="$2"
				shift 2
				;;
			--force)
				force=true
				shift
				;;
			--root)
				if [[ $# -lt 2 ]]; then
					log_error "--root requires an argument"
					exit_with_code "validation"
				fi
				root_path="$2"
				shift 2
				;;
			*)
				log_error "Unknown option for remove command: $1"
				exit_with_code "validation"
				;;
		esac
	done

	# Check if we're in a git repository
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		log_error "Not in a Git repository"
		exit_with_code "precondition"
	fi

	# Source service layer
	local script_dir
	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	if ! source "$script_dir/../services/worktree_service.sh"; then
		log_error "Failed to load worktree service"
		exit_with_code "operation_failed"
	fi

	# Parse worktrees from git
	parse_worktree_list

	# Get branch name for logging
	local branch_name
	if worktree_exists "$target_name"; then
		branch_name=$(get_worktree_field "$target_name" "branch")
	fi

	# Use service layer for removal
	local remove_result
	local service_exit_code=0

	# Call service layer remove function
	if remove_result=$(remove_worktree "$target_name" "$force" "$delete_branch" "$merged_into" 2>&1); then
		service_exit_code=0
	else
		service_exit_code=$?
	fi

	# Handle service layer response
	if [[ $service_exit_code -ne 0 ]]; then
		# Parse error from service layer and log appropriately
		local error_msg
		error_msg=$(echo "$remove_result" | grep -o '"error": "[^"]*"' | cut -d'"' -f4)

		if [[ -n "$error_msg" ]]; then
			log_error "$error_msg"
		else
			log_error "Failed to remove worktree"
		fi

		# Map service error codes to CLI exit codes
		case $service_exit_code in
			10) exit_with_code "validation" ;;
			12) exit_with_code "not_found" ;;
			15) exit_with_code "unsafe" ;;
			*) exit_with_code "operation_failed" ;;
		esac
	fi

	# Parse success response
	local removed branch_deleted
	removed=$(echo "$remove_result" | grep -o '"removed": [^,}]*' | cut -d':' -f2 | tr -d ' ')
	branch_deleted=$(echo "$remove_result" | grep -o '"branchDeleted": [^,}]*' | cut -d':' -f2 | tr -d ' ')

	# Format output
	if [[ "$format" == "json" ]]; then
		local json_output
		json_output=$(json_format_remove "$removed" "$branch_deleted")
		echo "$json_output"
	else
		if [[ "$removed" == "true" ]]; then
			echo "Removed worktree '$target_name'"
			if [[ "$branch_deleted" == "true" ]]; then
				echo "Deleted branch '$branch_name'"
			fi
		fi
	fi

	log_info "Remove operation completed for: $target_name"
}

handle_status_command() {
	local format="$1"
	shift

	# Check for help flag first
	for arg in "$@"; do
		if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
			show_status_help
			exit 0
		fi
	done

	# Default values
	local root_path=""

	# Parse status-specific arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
			--root)
				if [[ $# -lt 2 ]]; then
					log_error "--root requires an argument"
					exit_with_code "validation"
				fi
				root_path="$2"
				shift 2
				;;
			*)
				log_error "Unknown option for status command: $1"
				exit_with_code "validation"
				;;
		esac
	done

	# Get current worktree path
	local current_path
	if ! current_path=$(git rev-parse --show-toplevel 2>/dev/null); then
		log_error "Not in a Git repository"
		exit_with_code "precondition"
	fi

	# Get current branch
	local current_branch
	if ! current_branch=$(git branch --show-current 2>/dev/null); then
		log_error "Could not determine current branch"
		exit_with_code "precondition"
	fi

	# Parse worktree list to find current worktree info
	parse_worktree_list

	local worktree_name=""
	local worktree_path=""

	# Find the worktree that matches our current path
	local found_worktree=false
	for entry in "${WORKTREE_DATA[@]}"; do
		IFS='|' read -r name path branch head <<<"$entry"

		# Resolve both paths to handle symlinks
		local resolved_current_path resolved_entry_path
		resolved_current_path=$(cd "$current_path" && pwd -P 2>/dev/null) || resolved_current_path="$current_path"
		resolved_entry_path=$(cd "$path" 2>/dev/null && pwd -P 2>/dev/null) || resolved_entry_path="$path"

		if [[ "$resolved_current_path" == "$resolved_entry_path" ]]; then
			worktree_name="$name"
			worktree_path="$path"
			found_worktree=true
			break
		fi
	done

	if [[ "$found_worktree" != "true" ]]; then
		log_error "Current directory is not a recognized worktree"
		exit_with_code "not_found"
	fi

	# Try to determine base reference
	local base_ref=""
	if ! base_ref=$(get_default_branch 2>/dev/null); then
		base_ref="main" # fallback
	fi

	# Try to find a more specific base using merge-base
	local merge_base=""
	for potential_base in main master "$base_ref"; do
		if merge_base=$(git merge-base "$current_branch" "$potential_base" 2>/dev/null); then
			# Check if this base branch actually exists
			if git show-ref --verify --quiet "refs/heads/$potential_base" 2>/dev/null ||
				git show-ref --verify --quiet "refs/remotes/origin/$potential_base" 2>/dev/null; then
				base_ref="$potential_base"
				break
			fi
		fi
	done

	# Output results
	if [[ "$format" == "json" ]]; then
		local json_obj
		json_obj=$(json_build_object \
			"name" "$worktree_name" \
			"baseRef" "$base_ref" \
			"path" "$worktree_path")
		echo "$json_obj"
	else
		echo "Worktree: $worktree_name"
		echo "Base: $base_ref"
		echo "Path: $worktree_path"
	fi
}

handle_list_command() {
	local format="$1"
	shift

	# Check for help flag first
	for arg in "$@"; do
		if [[ "$arg" == "--help" || "$arg" == "-h" ]]; then
			show_list_help
			exit 0
		fi
	done

	# Default values
	local filter_name=""
	local filter_base=""
	local page="1"
	local page_size="20"
	local root_path=""
	local include_status="true"

	# Parse list-specific arguments
	while [[ $# -gt 0 ]]; do
		case $1 in
			--filter-name)
				if [[ $# -lt 2 ]]; then
					log_error "Error: --filter-name requires an argument"
					exit_with_code "validation"
				fi
				filter_name="$2"
				shift 2
				;;
			--filter-base)
				if [[ $# -lt 2 ]]; then
					log_error "Error: --filter-base requires an argument"
					exit_with_code "validation"
				fi
				filter_base="$2"
				shift 2
				;;
			--page)
				if [[ $# -lt 2 ]]; then
					log_error "Error: --page requires an argument"
					exit_with_code "validation"
				fi
				page="$2"
				shift 2
				;;
			--page-size)
				if [[ $# -lt 2 ]]; then
					log_error "Error: --page-size requires an argument"
					exit_with_code "validation"
				fi
				page_size="$2"
				shift 2
				;;
			--root)
				if [[ $# -lt 2 ]]; then
					log_error "--root requires an argument"
					exit_with_code "validation"
				fi
				root_path="$2"
				shift 2
				;;
			--no-status)
				include_status="false"
				shift
				;;
			*)
				log_error "Error: Unknown option for list command: $1"
				exit_with_code "validation"
				;;
		esac
	done

	# Check if we're in a git repository
	if ! git rev-parse --git-dir >/dev/null 2>&1; then
		log_error "Not in a Git repository"
		exit_with_code "precondition"
	fi

	# Validate and build query parameters
	local query_params
	if ! query_params=$(build_list_query "$filter_name" "$filter_base" "$page" "$page_size" 2>&1); then
		log_error "Invalid parameters: $query_params"
		exit_with_code "validation"
	fi

	# Parse query parameters back
	IFS='|' read -r filter_name filter_base page page_size <<<"$query_params"

	# Parse worktrees from git
	parse_worktree_list

	# Get all worktree names
	local all_names=()
	while IFS= read -r name; do
		all_names+=("$name")
	done < <(list_worktree_names)

	# Performance guard: warn about large repositories
	local total_worktrees=${#all_names[@]}
	if [[ $total_worktrees -gt 100 ]]; then
		log_warning "Large repository detected ($total_worktrees worktrees). Consider using filters to improve performance."
		if [[ "$include_status" == "true" ]]; then
			log_info "Use --no-status flag to skip expensive status checks and improve performance."
		fi
	fi

	# Apply filters
	local filtered_names=()
	for name in "${all_names[@]}"; do
		local branch
		branch=$(get_worktree_field "$name" "branch") || continue

		if filter_matches "$filter_name" "$filter_base" "$name" "$branch"; then
			filtered_names+=("$name")
		fi
	done

	# Apply pagination
	local total=${#filtered_names[@]}
	local start_index=$(((page - 1) * page_size))
	local end_index=$((start_index + page_size))

	if [[ $start_index -ge $total ]]; then
		start_index=$total
		end_index=$total
	elif [[ $end_index -gt $total ]]; then
		end_index=$total
	fi

	local page_names=()
	if [[ ${#filtered_names[@]} -gt 0 && $start_index -lt ${#filtered_names[@]} ]]; then
		page_names=("${filtered_names[@]:$start_index:$((end_index - start_index))}")
	fi

	# Format output
	if [[ "$format" == "json" ]]; then
		if [[ ${#page_names[@]} -eq 0 ]]; then
			format_json_output "$total" "$page" "$page_size" "$include_status"
		else
			format_json_output "$total" "$page" "$page_size" "$include_status" "${page_names[@]}"
		fi
	else
		if [[ ${#page_names[@]} -eq 0 ]]; then
			format_text_output
		else
			format_text_output "${page_names[@]}"
		fi
	fi

	# Add pagination info for JSON
	if [[ "$format" == "json" ]]; then
		# This is handled in format_json_output
		:
	else
		# Show pagination info for text format
		if [[ $total -gt 0 && ($page -gt 1 || $end_index -lt $total) ]]; then
			local start_item=$((start_index + 1))
			log_info "Showing $start_item-$end_index of $total worktrees (page $page of $(((total + page_size - 1) / page_size)))"
		fi
	fi
}

format_json_output() {
	local total="$1"
	local page="$2"
	local page_size="$3"
	local include_status="$4"
	shift 4
	local names=()
	if [[ $# -gt 0 ]]; then
		names=("$@")
	fi

	local items_array="["
	local first=true

	for name in "${names[@]+"${names[@]}"}"; do
		if [[ "$first" == "true" ]]; then
			first=false
		else
			items_array+=","
		fi

		local branch path base_ref worktree_obj
		branch=$(get_worktree_field "$name" "branch")
		path=$(get_worktree_field "$name" "path")
		base_ref="$branch" # For baseRef, we'll use the branch for now

		if [[ "$include_status" == "true" ]]; then
			local is_active is_dirty has_unpushed
			is_active=$(get_worktree_field "$name" "isActive")
			is_dirty=$(get_worktree_field "$name" "isDirty")
			has_unpushed=$(get_worktree_field "$name" "hasUnpushedCommits")
			worktree_obj=$(json_format_worktree "$name" "$branch" "$base_ref" "$path" "$is_active" "$is_dirty" "$has_unpushed")
		else
			# Format without expensive status fields
			worktree_obj=$(json_format_basic_worktree "$name" "$branch" "$base_ref" "$path")
		fi
		items_array+="$worktree_obj"
	done

	items_array+="]"

	local pagination_obj
	pagination_obj=$(json_format_pagination "$items_array" "$page" "$page_size" "$total")

	echo "$pagination_obj"
}

format_text_output() {
	local names=()
	if [[ $# -gt 0 ]]; then
		names=("$@")
	fi

	if [[ ${#names[@]} -eq 0 ]]; then
		echo "No worktrees found"
		return
	fi

	# Print header
	printf "%-20s %-20s %-15s %-50s\n" "NAME" "BRANCH" "STATUS" "PATH"
	printf "%-20s %-20s %-15s %-50s\n" "----" "------" "------" "----"

	# Print worktree information
	for name in "${names[@]+"${names[@]}"}"; do
		local branch path is_active is_dirty has_unpushed
		branch=$(get_worktree_field "$name" "branch")
		path=$(get_worktree_field "$name" "path")
		is_active=$(get_worktree_field "$name" "isActive")
		is_dirty=$(get_worktree_field "$name" "isDirty")
		has_unpushed=$(get_worktree_field "$name" "hasUnpushedCommits")

		local status=""
		if [[ "$is_active" == "true" ]]; then
			status+="active"
		fi
		if [[ "$is_dirty" == "true" ]]; then
			[[ -n "$status" ]] && status+=","
			status+="dirty"
		fi
		if [[ "$has_unpushed" == "true" ]]; then
			[[ -n "$status" ]] && status+=","
			status+="unpushed"
		fi
		[[ -z "$status" ]] && status="clean"

		printf "%-20s %-20s %-15s %-50s\n" "$name" "$branch" "$status" "$path"
	done
}

main() {
	local format="text"
	local command=""

	# Parse global options
	while [[ $# -gt 0 ]]; do
		case $1 in
			--help | -h)
				show_help
				exit 0
				;;
			--version | -v)
				show_version
				exit 0
				;;
			--format)
				if [[ $# -lt 2 ]]; then
					echo "Error: --format requires an argument" >&2
					exit 2
				fi
				format="$2"
				shift 2
				;;
			create | list | switch | remove | status)
				command="$1"
				shift
				break
				;;
			-*)
				echo "Error: Unknown option $1" >&2
				exit 2
				;;
			*)
				echo "Error: Unknown command $1" >&2
				echo "Use 'worktrees --help' for usage information." >&2
				exit 2
				;;
		esac
	done

	# Validate format
	case $format in
		text | json) ;;
		*)
			echo "Error: Invalid format '$format'. Must be 'text' or 'json'" >&2
			exit 2
			;;
	esac

	# Handle commands (scaffolding only - no behaviors implemented)
	case $command in
		create)
			handle_create_command "$format" "$@"
			;;
		list)
			handle_list_command "$format" "$@"
			;;
		switch)
			handle_switch_command "$format" "$@"
			;;
		remove)
			handle_remove_command "$format" "$@"
			;;
		status)
			handle_status_command "$format" "$@"
			;;
		"")
			echo "Error: No command specified" >&2
			echo "Use 'worktrees --help' for usage information." >&2
			exit 2
			;;
		*)
			echo "Error: Unknown command '$command'" >&2
			echo "Use 'worktrees --help' for usage information." >&2
			exit 2
			;;
	esac
}

main "$@"

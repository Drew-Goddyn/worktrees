#!/bin/bash

set -euo pipefail

readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly VERSION="0.1.0"

# Source dependencies
source "$SCRIPT_DIR/../lib/io.sh"
source "$SCRIPT_DIR/../lib/json.sh"
source "$SCRIPT_DIR/../models/list_query.sh"
source "$SCRIPT_DIR/../models/worktree.sh"
source "$SCRIPT_DIR/../models/feature_name.sh"
source "$SCRIPT_DIR/../models/repository.sh"

show_help() {
    cat << EOF
worktrees - Manage Git feature worktrees

USAGE:
    worktrees [GLOBAL_OPTIONS] <COMMAND> [COMMAND_OPTIONS]

GLOBAL OPTIONS:
    --help, -h         Show this help message
    --version, -v      Show version information
    --format <format>  Output format (text|json) [default: text]

COMMANDS:
    create <name>      Create a new worktree
    list               List existing worktrees
    switch <name>      Switch to a worktree
    remove <name>      Remove a worktree
    status             Show current worktree status

Use 'worktrees <command> --help' for more information on a specific command.
EOF
}

show_version() {
    echo "worktrees $VERSION"
}

handle_create_command() {
    local format="$1"
    shift

    # Required positional argument: feature name
    if [[ $# -eq 0 ]]; then
        log_error "Feature name is required"
        echo "Usage: worktrees create <NNN-kebab-feature> [options]" >&2
        exit_with_code "validation"
    fi

    local feature_name="$1"
    shift

    # Default values
    local base_ref=""
    local root_path="${HOME}/.worktrees"
    local reuse_branch=false
    local sibling=""

    # Parse create-specific arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --base)
                if [[ $# -lt 2 ]]; then
                    log_error "--base requires an argument"
                    exit_with_code "validation"
                fi
                base_ref="$2"
                shift 2
                ;;
            --root)
                if [[ $# -lt 2 ]]; then
                    log_error "--root requires an argument"
                    exit_with_code "validation"
                fi
                root_path="$2"
                shift 2
                ;;
            --reuse-branch)
                reuse_branch=true
                shift
                ;;
            --sibling)
                if [[ $# -lt 2 ]]; then
                    log_error "--sibling requires an argument"
                    exit_with_code "validation"
                fi
                sibling="$2"
                shift 2
                ;;
            *)
                log_error "Unknown option for create command: $1"
                exit_with_code "validation"
                ;;
        esac
    done

    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a Git repository"
        exit_with_code "precondition"
    fi

    # Validate feature name format
    if ! validate_feature_name "$feature_name"; then
        exit_with_code "validation"
    fi

    # Check if feature name is reserved
    if is_reserved_name "$feature_name"; then
        log_error "Feature name '$feature_name' is reserved"
        exit_with_code "validation"
    fi

    # Detect default base branch if not provided
    if [[ -z "$base_ref" ]]; then
        if ! base_ref=$(get_default_branch); then
            log_error "Could not determine default base branch. Please specify with --base"
            exit_with_code "precondition"
        fi
        log_info "Using detected base branch: $base_ref"
    fi

    # Create root directory if it doesn't exist
    if [[ ! -d "$root_path" ]]; then
        if ! mkdir -p "$root_path"; then
            log_error "Failed to create worktree root directory: $root_path"
            exit_with_code "precondition"
        fi
        log_info "Created worktree root directory: $root_path"
    fi

    # Check if branch already exists and handle accordingly
    local branch_name="$feature_name"
    local branch_exists=false
    local branch_checked_out=false

    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
        branch_exists=true
        # Check if branch is already checked out in another worktree
        if git worktree list --porcelain | grep -q "branch refs/heads/$branch_name"; then
            branch_checked_out=true
        fi
    fi

    # Handle branch conflicts
    if [[ "$branch_checked_out" == "true" ]]; then
        if [[ -n "$sibling" ]]; then
            branch_name="${feature_name}-${sibling}"
            log_info "Using sibling branch: $branch_name"
        elif [[ "$reuse_branch" == "true" ]]; then
            log_error "Branch '$feature_name' is already checked out and --reuse-branch was specified"
            log_error "Use --sibling <suffix> to create a sibling branch instead"
            exit_with_code "conflict"
        else
            log_error "Branch '$feature_name' is already checked out in another worktree"
            log_error "Use --sibling <suffix> to create a sibling branch or --reuse-branch if appropriate"
            exit_with_code "conflict"
        fi
    fi

    # Determine final worktree path (use branch name for sibling directories)
    local worktree_name="$feature_name"
    if [[ -n "$sibling" ]]; then
        worktree_name="$branch_name"
    fi
    local worktree_path="$root_path/$worktree_name"

    # Check if worktree directory already exists
    if [[ -d "$worktree_path" ]]; then
        log_error "Worktree directory already exists: $worktree_path"
        exit_with_code "conflict"
    fi

    # Create the worktree
    local git_cmd=("git" "worktree" "add")

    if [[ "$branch_exists" == "true" && "$reuse_branch" == "true" && "$branch_checked_out" == "false" ]]; then
        # Reuse existing branch
        git_cmd+=("$worktree_path" "$branch_name")
        log_info "Reusing existing branch: $branch_name"
    elif [[ -n "$sibling" ]]; then
        # Create new sibling branch from base
        git_cmd+=("-b" "$branch_name" "$worktree_path" "$base_ref")
        log_info "Creating sibling branch '$branch_name' from '$base_ref'"
    else
        # Create new branch from base
        git_cmd+=("-b" "$branch_name" "$worktree_path" "$base_ref")
        log_info "Creating branch '$branch_name' from '$base_ref'"
    fi

    # Execute git worktree add command
    if ! "${git_cmd[@]}" 2>&1; then
        log_error "Failed to create worktree"
        exit_with_code "precondition"
    fi

    # Verify worktree was created successfully
    if [[ ! -d "$worktree_path" ]]; then
        log_error "Worktree directory was not created: $worktree_path"
        exit_with_code "precondition"
    fi

    # Format output
    if [[ "$format" == "json" ]]; then
        local json_output
        json_output=$(json_format_worktree "$worktree_name" "$branch_name" "$base_ref" "$worktree_path" "true" "false" "false")
        echo "$json_output"
    else
        echo "Created worktree '$worktree_name' at $worktree_path"
        echo "Branch: $branch_name (from $base_ref)"
    fi

    log_info "Successfully created worktree: $worktree_name"
}

handle_list_command() {
    local format="$1"
    shift

    # Default values
    local filter_name=""
    local filter_base=""
    local page="1"
    local page_size="20"

    # Parse list-specific arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --filter-name)
                if [[ $# -lt 2 ]]; then
                    log_error "Error: --filter-name requires an argument"
                    exit_with_code "validation"
                fi
                filter_name="$2"
                shift 2
                ;;
            --filter-base)
                if [[ $# -lt 2 ]]; then
                    log_error "Error: --filter-base requires an argument"
                    exit_with_code "validation"
                fi
                filter_base="$2"
                shift 2
                ;;
            --page)
                if [[ $# -lt 2 ]]; then
                    log_error "Error: --page requires an argument"
                    exit_with_code "validation"
                fi
                page="$2"
                shift 2
                ;;
            --page-size)
                if [[ $# -lt 2 ]]; then
                    log_error "Error: --page-size requires an argument"
                    exit_with_code "validation"
                fi
                page_size="$2"
                shift 2
                ;;
            *)
                log_error "Error: Unknown option for list command: $1"
                exit_with_code "validation"
                ;;
        esac
    done

    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        log_error "Not in a Git repository"
        exit_with_code "precondition"
    fi

    # Validate and build query parameters
    local query_params
    if ! query_params=$(build_list_query "$filter_name" "$filter_base" "$page" "$page_size" 2>&1); then
        log_error "Invalid parameters: $query_params"
        exit_with_code "validation"
    fi

    # Parse query parameters back
    IFS='|' read -r filter_name filter_base page page_size <<< "$query_params"

    # Parse worktrees from git
    parse_worktree_list

    # Get all worktree names
    local all_names=()
    while IFS= read -r name; do
        all_names+=("$name")
    done < <(list_worktree_names)

    # Apply filters
    local filtered_names=()
    for name in "${all_names[@]}"; do
        local branch
        branch=$(get_worktree_field "$name" "branch") || continue

        if filter_matches "$filter_name" "$filter_base" "$name" "$branch"; then
            filtered_names+=("$name")
        fi
    done

    # Apply pagination
    local total=${#filtered_names[@]}
    local start_index=$(( (page - 1) * page_size ))
    local end_index=$(( start_index + page_size ))

    if [[ $start_index -ge $total ]]; then
        start_index=$total
        end_index=$total
    elif [[ $end_index -gt $total ]]; then
        end_index=$total
    fi

    local page_names=()
    if [[ ${#filtered_names[@]} -gt 0 && $start_index -lt ${#filtered_names[@]} ]]; then
        page_names=("${filtered_names[@]:$start_index:$((end_index - start_index))}")
    fi

    # Format output
    if [[ "$format" == "json" ]]; then
        if [[ ${#page_names[@]} -eq 0 ]]; then
            format_json_output "$total" "$page" "$page_size"
        else
            format_json_output "$total" "$page" "$page_size" "${page_names[@]}"
        fi
    else
        if [[ ${#page_names[@]} -eq 0 ]]; then
            format_text_output
        else
            format_text_output "${page_names[@]}"
        fi
    fi

    # Add pagination info for JSON
    if [[ "$format" == "json" ]]; then
        # This is handled in format_json_output
        :
    else
        # Show pagination info for text format
        if [[ $total -gt 0 && ($page > 1 || $end_index < $total) ]]; then
            local start_item=$((start_index + 1))
            log_info "Showing $start_item-$end_index of $total worktrees (page $page of $(( (total + page_size - 1) / page_size )))"
        fi
    fi
}

format_json_output() {
    local total="$1"
    local page="$2"
    local page_size="$3"
    shift 3
    local names=()
    if [[ $# -gt 0 ]]; then
        names=("$@")
    fi

    local items_array="["
    local first=true

    for name in "${names[@]+"${names[@]}"}"; do
        if [[ "$first" == "true" ]]; then
            first=false
        else
            items_array+=","
        fi

        local branch path is_active is_dirty has_unpushed base_ref
        branch=$(get_worktree_field "$name" "branch")
        path=$(get_worktree_field "$name" "path")
        is_active=$(get_worktree_field "$name" "isActive")
        is_dirty=$(get_worktree_field "$name" "isDirty")
        has_unpushed=$(get_worktree_field "$name" "hasUnpushedCommits")

        # For baseRef, we'll use the branch for now (this could be enhanced later)
        base_ref="$branch"

        local worktree_obj
        worktree_obj=$(json_format_worktree "$name" "$branch" "$base_ref" "$path" "$is_active" "$is_dirty" "$has_unpushed")
        items_array+="$worktree_obj"
    done

    items_array+="]"

    local pagination_obj
    pagination_obj=$(json_format_pagination "$items_array" "$page" "$page_size" "$total")

    echo "$pagination_obj"
}

format_text_output() {
    local names=()
    if [[ $# -gt 0 ]]; then
        names=("$@")
    fi

    if [[ ${#names[@]} -eq 0 ]]; then
        echo "No worktrees found"
        return
    fi

    # Print header
    printf "%-20s %-20s %-15s %-50s\n" "NAME" "BRANCH" "STATUS" "PATH"
    printf "%-20s %-20s %-15s %-50s\n" "----" "------" "------" "----"

    # Print worktree information
    for name in "${names[@]+"${names[@]}"}"; do
        local branch path is_active is_dirty has_unpushed
        branch=$(get_worktree_field "$name" "branch")
        path=$(get_worktree_field "$name" "path")
        is_active=$(get_worktree_field "$name" "isActive")
        is_dirty=$(get_worktree_field "$name" "isDirty")
        has_unpushed=$(get_worktree_field "$name" "hasUnpushedCommits")

        local status=""
        if [[ "$is_active" == "true" ]]; then
            status+="active"
        fi
        if [[ "$is_dirty" == "true" ]]; then
            [[ -n "$status" ]] && status+=","
            status+="dirty"
        fi
        if [[ "$has_unpushed" == "true" ]]; then
            [[ -n "$status" ]] && status+=","
            status+="unpushed"
        fi
        [[ -z "$status" ]] && status="clean"

        printf "%-20s %-20s %-15s %-50s\n" "$name" "$branch" "$status" "$path"
    done
}

main() {
    local format="text"
    local command=""

    # Parse global options
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --version|-v)
                show_version
                exit 0
                ;;
            --format)
                if [[ $# -lt 2 ]]; then
                    echo "Error: --format requires an argument" >&2
                    exit 2
                fi
                format="$2"
                shift 2
                ;;
            create|list|switch|remove|status)
                command="$1"
                shift
                break
                ;;
            -*)
                echo "Error: Unknown option $1" >&2
                exit 2
                ;;
            *)
                echo "Error: Unknown command $1" >&2
                echo "Use 'worktrees --help' for usage information." >&2
                exit 2
                ;;
        esac
    done

    # Validate format
    case $format in
        text|json)
            ;;
        *)
            echo "Error: Invalid format '$format'. Must be 'text' or 'json'" >&2
            exit 2
            ;;
    esac

    # Handle commands (scaffolding only - no behaviors implemented)
    case $command in
        create)
            handle_create_command "$format" "$@"
            ;;
        list)
            handle_list_command "$format" "$@"
            ;;
        switch)
            echo "Error: 'switch' command not yet implemented" >&2
            exit 1
            ;;
        remove)
            echo "Error: 'remove' command not yet implemented" >&2
            exit 1
            ;;
        status)
            echo "Error: 'status' command not yet implemented" >&2
            exit 1
            ;;
        "")
            echo "Error: No command specified" >&2
            echo "Use 'worktrees --help' for usage information." >&2
            exit 2
            ;;
        *)
            echo "Error: Unknown command '$command'" >&2
            echo "Use 'worktrees --help' for usage information." >&2
            exit 2
            ;;
    esac
}

main "$@"